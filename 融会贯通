(一)循环移位问题
NO.189 旋转数组
数组可以任意存取
法一：空间复杂度为O(N)的解法
当k很大时，只需对n取模，将求模的值当成新的k。
复制一个完全一样的数组，每次移动时从新的数组里取数，算法空间复杂度为O(N)
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        copy = nums.copy()#复制数组
        n = len(nums)
        for i in range(n):
            nums[(i + k) % n] = copy[i]#新数组加上位移后对N取模
        return

法二：三次翻转，空间复杂度为O(1)
先对整个数组进行翻转，再从k处分隔数组，最后对分隔后的两个数组分别进行翻转。
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(left, right):
            while left < right:#翻转方法
                nums[left], nums[right] = nums[right], nums[left]#这种写法只有python可使用
                left += 1
                right -= 1
        n = len(nums)
        k %= n
        reverse(0, n-1)
        reverse(0, k-1)
        reverse(k, n-1)
        return nums


class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(left, right):#翻转函数
            while left < right:
                temp = nums[left]#临时变量交换，适用于各种编程语言
                nums[left] = nums[right]
                nums[right] = temp
                left += 1
                right -= 1
        
        n = len(nums)
        k %= n#对k取模
        reverse(0, n-1)#第一次交换
        reverse(0, k-1)#第二次交换
        reverse(k, n-1)#第三次交换
        return nums

NO.61 旋转链表
链表不支持随机访问，因此不能借助下标交换元素。
链表更简单，找到断点，重新拼接链表即可。断点是第n - k%n 个节点
:=海象运算符，也叫赋值表达式
语法格式： variable_name := expression or value即一个变量名后面跟一个表达式或一个值，可以看作一直新的赋值运算符
闭合为环，找到新的尾节点后，将其next节点设为头节点，断开环即可。
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if k == 0 or not head or not head.next:#k为0或链表为空或只有一个节点，返回原链表
            return head
        
        n = 1
        cur = head
        while cur.next:#计算链表长度
            cur = cur.next#指针后移，长度+1
            n += 1
        
        remain = n - k % n#需要移动到新链表头节点的步数
        cur.next = head#之前指针已到尾节点，连接头节点，成环
        while remain:#从尾节点开始，移动remain步，找到新的尾节点
            cur = cur.next
            remain -= 1
        
        res = cur.next#新链表表头是新尾节点的下一个节点
        cur.next = None#断开环形链表，尾节点的next指针置为None

        return res

(二)编辑距离
经典的动态规划问题
NO.72 
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)#word1和word2的长度
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]#动态规划建立二维数组，初始值默认都为0
        for i in range(m+1):#当word2为空字符串时，将word1的前i个字符转换为空字符串需要删除i次
            dp[i][0] = i 
        for j in range(n+1):#当word1为空字符串时，将空字符串转换为word2的前j个需要增加j次
            dp[0][j] = j
        for i in range(1, m+1):#填充dp数组
            for j in range(1, n+1):
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1#取修改、删除、增加三种里面最小的次数加一
                if word1[i-1] == word2[j-1]:#如果刚好两个字母相同，不用加一，直接使用
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
        return dp[m][n]

(三)第K问题
1、堆
NO.215 数组中的第K个最大元素

python heapy:堆队列算法，其实现使用了数组，堆是一种二叉树，这里实现的是小根堆
常用函数：heapq.heappush(heap, item):将item加入堆中
heapq.pop(heap):弹出并返回heap的最小元素，保持堆的特性，如果堆为空，返回IndexError，使用heap[0]只访问最小元素而不弹出
heapq.heappushpop(heap, item):将item放入堆中，并弹出最小元素，该操作比heappush()+heappop()更有效率。

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        h = []#建立一个空堆队列
        for num in nums:#遍历数组中的每一个数
            heapq.heappush(h, num)#将数添加到堆里面
            if len(h) > k:#如果超过k个元素，则删除堆顶（最小）元素
                heapq.heappop(h)
        return h[0]#完成之后，堆顶元素就是这第k大元素

NO.703 数据流中的第K大元素

2、二分法
NO.230 二叉搜索树中第K小的元素

NO.378 有序矩阵中第K小的元素

NO.668 乘法表中的第K小元素

