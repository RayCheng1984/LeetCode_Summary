(一)循环移位问题
NO.189 旋转数组
数组可以任意存取
法一：空间复杂度为O(N)的解法
当k很大时，只需对n取模，将求模的值当成新的k。
复制一个完全一样的数组，每次移动时从新的数组里取数，算法空间复杂度为O(N)
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        copy = nums.copy()#复制数组
        n = len(nums)
        for i in range(n):
            nums[(i + k) % n] = copy[i]#新数组加上位移后对N取模
        return

法二：三次翻转，空间复杂度为O(1)
先对整个数组进行翻转，再从k处分隔数组，最后对分隔后的两个数组分别进行翻转。
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(left, right):
            while left < right:#翻转方法
                nums[left], nums[right] = nums[right], nums[left]#这种写法只有python可使用
                left += 1
                right -= 1
        n = len(nums)
        k %= n
        reverse(0, n-1)
        reverse(0, k-1)
        reverse(k, n-1)
        return nums


class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(left, right):#翻转函数
            while left < right:
                temp = nums[left]#临时变量交换，适用于各种编程语言
                nums[left] = nums[right]
                nums[right] = temp
                left += 1
                right -= 1
        
        n = len(nums)
        k %= n#对k取模
        reverse(0, n-1)#第一次交换
        reverse(0, k-1)#第二次交换
        reverse(k, n-1)#第三次交换
        return nums

NO.61 旋转链表
链表不支持随机访问，因此不能借助下标交换元素。
链表更简单，找到断点，重新拼接链表即可。断点是第n - k%n 个节点
:=海象运算符，也叫赋值表达式
语法格式： variable_name := expression or value即一个变量名后面跟一个表达式或一个值，可以看作一直新的赋值运算符
闭合为环，找到新的尾节点后，将其next节点设为头节点，断开环即可。
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if k == 0 or not head or not head.next:#k为0或链表为空或只有一个节点，返回原链表
            return head
        
        n = 1
        cur = head
        while cur.next:#计算链表长度
            cur = cur.next#指针后移，长度+1
            n += 1
        
        remain = n - k % n#需要移动到新链表头节点的步数
        cur.next = head#之前指针已到尾节点，连接头节点，成环
        while remain:#从尾节点开始，移动remain步，找到新的尾节点
            cur = cur.next
            remain -= 1
        
        res = cur.next#新链表表头是新尾节点的下一个节点
        cur.next = None#断开环形链表，尾节点的next指针置为None

        return res

(二)编辑距离
经典的动态规划问题
NO.72 
