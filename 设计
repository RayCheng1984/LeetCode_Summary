NO.155 最小栈
此题重点是在常数时间内检索到最小元素的栈
入栈：在栈内保存元组(当前值, 栈内最小值)
出栈：pop()函数删除栈顶元素
栈顶值:top()栈顶元素的第一个值
最小值:getMin()栈顶元素的第二个值
***注意：在判断栈是否为空时， not self.stack != self.stack is None， 因为栈已经建立，所有not self.stack是false, 但是self.stack is None是True

元组与列表类似，但是元组不能更改，元组使用小括号，列表使用方括号
Python里的self:
self代表类的实例，而非类
self的主要作用是允许类的实例方法访问类的属性和其他方法


NO.208 实现Trie树(前缀树)
ord函数：ord(c)其中c为字符，返回其对应的十进制整数
查找前缀：枚举前缀的每一位，看字符串是否存在字符的当前为是这个位，若存在，就在符合要求的字符串中去查找下一位
插入字符串：
如果当前节点子节点列中， ch位置没有节点，则新建一个节点；然后更新node为子节点，加入下一个字符，node初始为前缀树的根节点root
查找前缀：
与插入过程类似，如果当前节点的子节点列表中，ch位置没有节点，说明匹配不上，前缀不存在退出查找，否则更新node为子节点，寻找下一个字符，node初始为前缀树的根节点root
标志位标记文章字符串：如何判断是一个完整字符串还是某个字符串的前缀？
引入标志标记位完整串，在插入最后一个字符后其标志位为True

三个函数模式差不多，这是最后返回值略有不同
self.root = {}

node = self.root
for c in word:
if c not in node:
node[c] = {}
node = node[c]
node['#'] in node


NO.146 LRU缓存机制 least recently used最近最少使用置换算法
super()函数用于调用父类方法，在子类中可以使用super()来访问父类的属性和方法，从而实现对父类的调用和扩展
MRO(method resolution order)方法解析顺序：对于定义的每一个类，python会计算出一个MRO表，它代表了类继承的顺序
MRO原则：子类永远在父类前面——如果有多个父类，根据他们在列表中的顺序进行检查——如果对下一个类存在多个合法选择，选择第一个父类

collections是python内置的集合模块，里面提供dict, list, set, tuple的替代选择
常用方法：1、namedtuple():命名元组，用其可以很方便的定义一种数据类型，在里面可以使用属性而不是索引来使用tuple的某个元素
2、deque():双端队列，使用列表存储数据，查找很快但是删除和插入很慢，deque是可以实现高效插入和删除的双向列表，方法有append(), pop(), appendleft(), popleft()
3、defaultdict():默认值字典，使用普通字典，key不存在就会报错，用defaultdict当key不存在时，就会返回默认值
4、OrderedDict():有序字典，普通字典是无序的，如果要保持key的顺序，可以用OrderedDict()。
它会按照key插入的顺序排序，它可以实现一个先进先出的dict， 当容量超出限制时，删除最早添加的key
popitem(last = False/True)：该方法删除一个键值对，如果last = False，则先进先出， 如果last = True则后进先出
move_to_end(key, last = True):将现有key移动到字典的末尾
5、counter():是一个简单的计数器，如统计字符出现的个数，它是字典的一个子类

法一：Python中有实现好的结合了哈希表和双链表的数据结构OrderedDict()，继承该方法，可以简单实现get和put
python继承：将父类名写在参数里面
class LRUCache(collections.OrderedDict): 
def _init_(self, capacity:int):
super()._init_()
self.capacity = capacity

def get(self, key:int)-> int:
if key not in self:
return -1
self.move_to_end(key)
return self[key]

def put(self, key: int, value: int)->None:
if key in self::
self.move_to_end(key)
self[key] = value
if len(self) > self.capacity:
self.popitem(last = False)

法二：哈希表+双链表
get(key): O(1)常数时间取值，哈希表符合要求
put(key, value): O(1)时间，能够在常数时间插入和删除，如果想在常数时间将链表的中间节点移动到尾部，需要在O(1)时间内获得当前节点的前驱节点。
