一、两数之和
法一：
暴力枚举，双层循环
注意此题要求返回下标
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)#求数组长度
        for i in range(n):#遍历每个数
            for j in range(i+1, n):
                if nums[i] + nums[j] == target:#当两数之和等于目标值时
                    return [i, j]#返回下标
        return []

法二：
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)#求数组长度
        map = {}#建立哈希表
        for i in range(n):
            if target - nums[i] in map:#当目标值减去当前值剩下的差值在哈希表里
                return [i, map[target - nums[i]]]#用哈希表找到差值的下标
            else:
                map[nums[i]] = i #差值不在哈希表里，将当前数及下标放入
        return []

二、三数之和
几数之和就需要去几次重
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)#数组长度
        nums.sort()#对数组进行排序，此题不需要下标，可以排序
        res = []#放答案数组
        for i in range(n-2):#3个数，两个指针，只需要循环到n-2
            if i > 0 and nums[i] == nums[i-1]:#去重，重复值只保留的一个出现的
                continue
            left, right = i + 1, n - 1#左右指针
            while left < right:#指针不越界时
                if nums[i] + nums[left] + nums[right] < 0:#和小于0，左指针加1，重复值不影响结果，不用去重
                    left += 1
                elif nums[i] + nums[left] + nums[right] > 0:#和大于0，右指针减1，重复值不影响结果，不用去重
                    right -= 1
                else:#等于0，是答案，但是答案不唯一，要去重
                    res.append([nums[i], nums[left], nums[right]])#加入答案
                    while left < right and nums[left] == nums[left+1]:#去重，指针不越界且左边重复，不能用-1，否则会小于i造成越界
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:#去重，指针不越界且右边重复，不能用+1，否则会越界
                        right -= 1
                    left += 1#已经添加一个答案，继续
                    right -= 1#继续
        return res

三、四数之和
几数之和就需要去几次重
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        n = len(nums)#数组长度
        nums.sort()#不要求下标，可以排序
        res = []#保存结果
        for i in range(n-3):#4个数，只需要循环到n-3
            if i > 0 and nums[i] == nums[i-1]:#第一个数去重
                continue
            for j in range(i+1, n-2):#只需循环到n-2
                if j > i+1 and nums[j] == nums[j-1]:#第二个数去重
                    continue
                left, right = j + 1, n-1 #左右指针
                while left < right: #不越界时
                    if nums[i] + nums[j] + nums[left] + nums[right] < target:#小于目标值，左指针+1，重复值不影响结果，不用去重
                        left += 1
                    elif nums[i] + nums[j] + nums[left] + nums[right] > target:#大于目标值，右指针-1，重复值不影响结果，不用去重
                        right -= 1
                    else:
                        res.append([nums[i], nums[j], nums[left], nums[right]])#添加结果
                        while left < right and nums[left] == nums[left + 1]:#去重，去除区间外侧的
                            left +=1
                        while left < right and nums[right] == nums[right - 1]:#去重，去除区间外侧的
                            right -= 1
                        left += 1 #去完重，左指针+1
                        right -= 1 #右指针-1
        return res


四、四数相加II
两两组合，两个双重循环
难点：使用map.get()方法
map.get（i+j, 0) + 1意味着当找到i+j时执行get[i+j]+1, 如果没找到，执行0+1

五、最接近的三数之和
一重循环+两个指针
找数可以排序，找索引值用字典
res存储num[0]+nums[1]+nums[2]的值，如果有更小的就更新，没有就返回res
注意指针问题都需保证i>0且循环时左指针<右指针

六、最大子数组和
（一）动态规划
构造一个新数组，返回新数组的最大值
如果前一个数大于0，那么将它加到当前元素上
if nums[i-1]>0:
  nums[i] += nums[i-1]
（二）贪心算法
当前元素之前的和小于0，则丢弃当前元素之前的数列
cur_sum = max_sum = nums[0]
cur_sum = max(cur_sum, nums[i])
max_sum = max(cur_sum, max_sum)

七、最大数
自定义比较比较，然后降序排列，最后以字符串形式拼接起来。
当由多个0组成时，返回'000'格式会报错，应当返回'0'

functools.cmp_to_key()将传统的比较函数转换为关键字函数，以便与sorted()、sort()等函数兼容
join函数用于连接字符串，语法：'连接符'.join(字符串序列)
sort默认升序，即reverse=False, 降序需改为reverse=True

八、分数到小数
若整除，返回str(numerator // denominator)
若符号不一致， ans += '-'，ans += (numerator // denominator), numerator = numerator % denominator
如果numerator != 0:
使用字典，当numerator在字典里时，根据其索引值返回f'{ans[:temp]}({ans[temp:]})'
如果不在字典里，建立键值对map[numerator] = len(ans)小数的索引值正好对应答案字符串的长度 numerator *=10, ans+=(numerator // denominator), numerator = numerator % denominator

九、最大整除子集（这道题目还是不太明白）
对数组排序，然后将每项拆分成数组，及形成数组的数组
建立一个最大序列用来存储结果
两重循环i，j, 判断nums[i] % nums[j] == 0 and len(dp[i]) < len(dp[j]) + 1,成立则将dp[i]更新为dp[j] + nums[i:i+1]
比较len(dp[i])与len(最大序列的长度）,成立则将len(最大序列）更新为dp[i]
最后返回最大序列

十、质数排列
定义质数判断函数，if num % i == 0:return false
计算质数的数量，is_prime, count++
return factorial(count) * factorial(n-count) % (10**9 + 7)
